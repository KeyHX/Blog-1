(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{595:function(s,e,v){"use strict";v.r(e);var _=v(16),t=Object(_.a)({},(function(){var s=this,e=s.$createElement,v=s._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h2",{attrs:{id:"_0x01-redis常见数据结构以及使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x01-redis常见数据结构以及使用场景"}},[s._v("#")]),s._v(" 0x01 Redis常见数据结构以及使用场景")]),s._v(" "),v("p",[v("strong",[s._v("string")])]),s._v(" "),v("p",[s._v("介绍：虽然Reids是C语言编写的，但是其string底层并没有采用C的字符串，而是自己构建了一种简单动态字符串")]),s._v(" "),v("p",[s._v("常用命令：set，get，strlen，exists，decr，incr，setex。。。")]),s._v(" "),v("p",[s._v("应用场景：一般用于需要计数的场景，比如用户的访问次数，热点文章的点赞数和转发数等等")]),s._v(" "),v("p",[v("strong",[s._v("list")])]),s._v(" "),v("p",[s._v("介绍：底层为双向链表")]),s._v(" "),v("p",[s._v("常用命令：rpush，lpush，rpop，lpop，lrange，llen。。。")]),s._v(" "),v("p",[s._v("应用场景：消息队列")]),s._v(" "),v("p",[v("strong",[s._v("hash")])]),s._v(" "),v("p",[s._v("介绍：类似于JDK1.8之前的HashMap，内部实现也差不多是数组+链表。")]),s._v(" "),v("p",[s._v("常用命令：hset，hmset，hexists，hget，hgetall，hkeys，hvals。。。")]),s._v(" "),v("p",[s._v("应用场景：系统中对象数据的存储")]),s._v(" "),v("p",[v("strong",[s._v("set")])]),s._v(" "),v("p",[s._v("介绍：类似于Java中的HashSet")]),s._v(" "),v("p",[s._v("常用命令：sadd，spop，smembers，sismember，scard，sinterstore，sunion等")]),s._v(" "),v("p",[s._v("应用场景：集合运算，比如集合的交集和并集")]),s._v(" "),v("p",[v("strong",[s._v("sorted set")])]),s._v(" "),v("p",[s._v("介绍：和set相比增加了一个权重参数score，使得集合中的元素可以根据score进行有序排列。")]),s._v(" "),v("p",[s._v("常用命令：zadd，zcard，zscore，zrange，zrevrange，zrem。。。")]),s._v(" "),v("p",[s._v("应用场景：需要对数据根据某个权重进行排序的场景。比如直播间礼物排行榜。")]),s._v(" "),v("h2",{attrs:{id:"_0x02-redis单线程多线程方面"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x02-redis单线程多线程方面"}},[s._v("#")]),s._v(" 0x02 Redis单线程多线程方面")]),s._v(" "),v("p",[v("strong",[s._v("Redis单线程为什么还快？")])]),s._v(" "),v("ol",[v("li",[s._v("单线程编程更容易实现并且更容易维护")]),s._v(" "),v("li",[s._v("Redis的瓶颈不在CPU，而是在于内存和网络")]),s._v(" "),v("li",[s._v("多线程会存在死锁以及线程上下文切换问题，会影响性能")]),s._v(" "),v("li",[s._v("I/O多路复用技术让Redis不需要创建额外的线程来监听大量客户端的连接，降低了资源消耗")])]),s._v(" "),v("h2",{attrs:{id:"_0x03-过期数据删除策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x03-过期数据删除策略"}},[s._v("#")]),s._v(" 0x03 过期数据删除策略")]),s._v(" "),v("p",[v("strong",[s._v("惰性删除：")]),s._v(" 在取出key的时候对数据进行过期检查。这样对CPU友好，但是会造成太多过期key没有被删除")]),s._v(" "),v("p",[v("strong",[s._v("定期删除：")]),s._v(" 每隔一段时间抽取一批key执行删除过期key操作。并且Redis底层会通过限制删除操作的时常和频率来减少删除操作对CPU的影响")]),s._v(" "),v("p",[s._v("定期删除对内存更加友好，惰性删除对CPU更加友好。所以Redis采用两者结合的方式进行过期数据删除")]),s._v(" "),v("h2",{attrs:{id:"_0x04-redis内存淘汰机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_0x04-redis内存淘汰机制"}},[s._v("#")]),s._v(" 0x04 Redis内存淘汰机制")]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("volatile-lru（least recently used）：")]),s._v(" 从已设置过期时间的数据集("),v("code",[s._v("server.db[i].expires")]),s._v(")中挑选最近最少使用的数据淘汰")]),s._v(" "),v("li",[v("strong",[s._v("volatile-ttl：")]),s._v(" 从已设置过期时间的数据集中挑选即将要过期的数据淘汰")]),s._v(" "),v("li",[v("strong",[s._v("volatile-random：")]),s._v(" 从已设置过期时间的数据集中任意选择数据淘汰")]),s._v(" "),v("li",[v("strong",[s._v("allkeys-lru：（least recently used）：")]),s._v(" 当内存不足以容纳新写入数据时，在键空间中，移出最近最少使用的key（最常用）")]),s._v(" "),v("li",[v("strong",[s._v("allkeys-random：")]),s._v(" 从数据集中任意选择数据淘汰")]),s._v(" "),v("li",[v("strong",[s._v("no-eviction：")]),s._v(" 禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。（基本没人使用）")]),s._v(" "),v("li",[v("strong",[s._v("volatile-lfu（least frequently used）：")]),s._v(" 从已设置过期时间的数据集中挑选最不经常使用的数据淘汰")]),s._v(" "),v("li",[v("strong",[s._v("allkeys-lfu（least frequently used）：")]),s._v(" 当内存不足以容纳新写入的数据时，在键空间中移出最不经常使用的key")])])])}),[],!1,null,null,null);e.default=t.exports}}]);